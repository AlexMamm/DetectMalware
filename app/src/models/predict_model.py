import torch
import pickle
import os
from models.preprocessing import convert_to_png
import numpy as np
from data.unpacker import get_pe_packer, get_unpacked_file
from models.train_model import CNN
import json


def predict(root_dir, path):
    binary_encoder = pickle.load(open(os.path.join(root_dir, 'models', 'binary_encoder.pickle'), 'rb'))
    binary_model = torch.load(open(os.path.join(root_dir, 'models', 'binary_classifier.pickle'), 'rb'))
    multi_encoder = pickle.load(open(os.path.join(root_dir, 'models', 'multi_encoder.pickle'), 'rb'))
    multi_model = torch.load(open(os.path.join(root_dir, 'models', 'multi_classifier.pickle'), 'rb'))
    predict_files = []
    json_path = '/'.join(path.split('/')[:-1])

    if os.path.isdir(path):
        for root, dirs, files in os.walk(path):
            for file in files:
                file_path = os.path.join(root,file)
                predict_files.append(file_path)
    elif os.path.isfile(path):
        predict_files.append(path)
    else:
        print('[!] Invalid path directory or file')
        return 1
    dict_ans = {}
    for file_path in predict_files:
        packer = get_pe_packer(file_path)
        if isinstance(packer, str) and packer == 'Except!':
            print(f'[*] Preprocessing: {file_path}')
            print(f'\t[-] Not PE File!')
        else:
            print(f'[*] Preprocessing: {file_path}')
            print(f'\t[+] PE Packer: {packer}')

            if isinstance(packer,list):
                get_unpacked_file(file_path)
                unpack_path = '/'.join(file_path.split('/')[:-1]) + '/unpacked_' + file_path.split('/')[-1]
                if os.path.isfile(unpack_path):
                    file_path = unpack_path

            convert_file = convert_to_png(file_path)
            os.remove(file_path + '.png')

            val = np.array([convert_file])
            val = val / 255
            val = torch.from_numpy(val)
            val = torch.unsqueeze(val, dim=1)

            binary_pred = binary_model(val).softmax(dim=1).detach().numpy()[0]
            binary_pred = [round(float(el),3) for el in binary_pred]

            if binary_pred[0] > binary_pred[1]:
                binary = 'benign'
                prob = binary_pred[0]
            else:
                binary = 'malicious'
                prob = binary_pred[1]

            multi_pred = multi_model(val).argmax(dim=1)
            multi_pred = multi_encoder.inverse_transform(multi_pred)
            multi = multi_pred[0]

            if isinstance(packer,list) and len(packer) == 1:
                packer = packer[0]

            if binary == 'benign':
                print(f'\t[+] Predict class: {binary}')
                dict_ans[file_path.split('/')[-1]] = {
                    'packer' : packer,
                    'predict' : binary,
                    'binary_probability' : prob,
                }
            else:
                print(f'\t[+] Predict class: {binary}.{multi}')
                dict_ans[file_path.split('/')[-1]] = {
                    'packer' : packer,
                    'predict' : f'{binary}.{multi}',
                    'binary_probability' : prob
                }

    with open(os.path.join(json_path, 'detect.json'), 'w', encoding='utf-8') as f:
        json.dump(dict_ans, f, ensure_ascii=False, indent=4)


if __name__ == '__main__':
    ROOT_DIR = '/'.join(os.path.dirname(os.path.abspath(__file__)).split('/')[:-2])
    PATH = '/home/alex/validation_sample/'
    predict(ROOT_DIR, PATH)
